<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Introduction</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<h2>Introduction</h2>

<p>The package <em>siland</em> aims to estimate the effects of landscape and local variables on a measurement of interest. 
Two methods are available which enable to estimate effect intensities but also the scale of the effect for landscape variables, without any a priori. </p>

<ul>
<li><p>The first one is based on buffer computed around location of observed data (<code>Bsiland</code>). </p></li>
<li><p>The second one (<code>Fsiland</code>) is based on estimation of Spatial Influence Function (SIF).The SIF function describes how the influence of a pixel/cell of a landscape variable is spatially distributed. We assume that the influence is maximal at the pixel location and decreases with the distance.  </p></li>
</ul>

<p>It is worth noting that the both methods simultaneously estimate intensities of effect and scales of effect using a numerical likelihood maximisation procedure. This means that the buffers radii (Bsiland) or the mean distances of the SIFs (Fsiland) are not given by the user but estimated for each landscape variable.</p>

<p><em>siland</em> package is designed to be a user-friendly tool: data format are commonly used (data.frame and shape files from GIS data), model expression is simple (classical formula as lm expression), various outputs are very easily computed: summary of estimates and tests, graphical maps of effects and graphical checking of likelihood maximisation. Based on linear model, it includes numerous extensions of linear model: interactions, random effects, GLM (binomial and poisson). It is also possible to build multiannual model. We detailed hereafter some examples of simple use of the <em>siland</em> package. (More details about the method can be find in <a href="https://www.biorxiv.org/content/10.1101/692566v1">https://www.biorxiv.org/content/10.1101/692566v1</a>. Package development on <a href="https://github.com/silandpackage/siland">https://github.com/silandpackage/siland</a>)</p>

<h2>A first example</h2>

<h3>Data</h3>

<p><em>siland</em> package requires two data objects:</p>

<ul>
<li> <strong>data.frame of located observations</strong> . <em>Data locations</em> have to be indicated in <em>columns &ldquo;X&rdquo; and &ldquo;Y&rdquo;</em>. The variable of interest as possible local variables are also included here. </li>
<li> <strong>sf object</strong> containing description of landscape variables. It can be created using the <code>st_read</code> function of the package <code>sf</code>. For instance if your GIS data (in shp format) are in the <em>FILE</em> file, named <em>NAME</em> (i.e.FILE contains NAME.shp, NAME.dbf,&hellip;), you can easily import your data in landdata using the command: </li>
</ul>

<pre><code class="r">landdata=st_read(dsn = &quot;FILE&quot;,layer=&quot;NAME&quot;)
</code></pre>

<p>Here, we use a toy example: the objects dataSiland and landSiland, included in <em>siland</em> package. You can load data using the <code>data</code> command. </p>

<pre><code class="r">library(siland)
data(dataSiland)
data(landSiland)
</code></pre>

<p><em>dataSiland</em> is a data.frame with columns: &ldquo;obs&rdquo;, variable of interest and &ldquo;x1&rdquo; variable, a continuous local variable.
The &ldquo;Id&rdquo; column gives the identification number of the plots where observations were made.
<em>landSiland</em> is an object of class sf where landscape is characterised by two features named L1 and L2. Landscape is described by polygons.
For each polygon, L1 is equal to 1 if the polygon is of type L1, 0 otherwise  (so is it for L2).   </p>

<pre><code class="r">str(dataSiland)
str(landSiland)
</code></pre>

<p>You can look at spatial configuration of the loaded data using the following commands :</p>

<pre><code class="r">library(ggplot2)
library(sf)
L1pol=st_geometry(landSiland[landSiland$L1==1,])#extract an sf object with only polygons of type L1 
L2pol=st_geometry(landSiland[landSiland$L2==1,])#extract an sf object with only polygons of type L2 
ggplot(landSiland)+
  geom_sf(colour=&quot;grey&quot;,fill=&quot;white&quot;)+
  geom_sf(data=L1pol,fill=&quot;red&quot;)+
  geom_sf(data=L2pol,fill=&quot;blue&quot;)+
  geom_point(data=dataSiland, aes(X,Y),col=&quot;green&quot;)
</code></pre>

<h3>Buffer approach : Bsiland()</h3>

<h3>Classical disks buffers (point observations)</h3>

<p>Buffer approach modelizes effect of lanscape variable with a constant intensity on a buffer (i.e. an area of constant radius) around the observation location. Estimating effects of the local variable x1 and landscape variables L1 and L2 on the variable of interest obs can be done with the command <code>Bsiland()</code>:</p>

<pre><code class="r">resB1=Bsiland(obs~x1+L1+L2,land=landSiland,data=dataSiland)
resB1
</code></pre>

<p>Coefficients are the parameter estimates. For a landscape variable, there are two values : for instance for L1, <code>L1</code> (-8.659) is the intensity of the effect and <code>B.L1</code> (106.117) is the estimated buffer size for L1. <code>AIC</code> is AIC the  of the model resB1 (Model: obs ~ x1 + L1 + L2) and <code>AIC(no landscape)</code> is the AIC with only local variable (Model0: obs ~ x1). <code>(No landscape effect) p-value</code> is related to the test of landscape global effect significativity, i.e. H0= &#39;Model0: obs ~ x1&#39; vs H1=&#39;Model: obs ~ x1 + L1 + L2&#39; (Likelihood ratio test).</p>

<p>Parameter estimates and tests can be obtained using the command <code>summary</code>:</p>

<pre><code class="r">summary(resB1)
</code></pre>

<p>Note that p.values are given conditionnaly to estimates of buffer radii.  </p>

<p><code>resB1$parambuffer</code> gives the vector of estimated buffers radii.
<code>resB1$buffer</code> gives a data.frame of the percentages of each landscape variable in buffers of estimated radii for each observation.</p>

<pre><code class="r">resB1$parambuffer
</code></pre>

<p>The <code>plotBsiland.land()</code> function gives a graphical representation of the estimation. 
The color intensity is the effect of the landscape variable i.e. the product of the occupancy percentage of the landscape variable in the buffer by the associated coeffcient. </p>

<pre><code class="r">plotBsiland.land(x=resB1,land=landSiland,data=dataSiland)
plotBsiland.land(x=resB1,land=landSiland,data=dataSiland,var=2)
</code></pre>

<h4>&ldquo;Doughnut&rdquo; buffers (polygonal observations)</h4>

<p>In function <code>Bsiland</code>, the argument <code>border=F</code> (by default) indicates that buffers are computed from the observations locations. Buffers are thus a circle of constant radius centered on observation locations.<br/>
The option <code>border=T</code> indicates that buffers are computed from the border of the polygon (observation plot) where observations are made. Then the buffers look much more like &ldquo;doughnuts&rdquo;, with an empty area in the center. </p>

<pre><code class="r">resB2=Bsiland(obs~x1+L1+L2,land=landSiland,data=dataSiland,family=gaussian,border=T)
resB2$parambuffer
plotBsiland.land(x=resB2,land=landSiland,data=dataSiland)
plotBsiland.land(x=resB2,land=landSiland,data=dataSiland,var=2)
</code></pre>

<h4>Visual check of likelihood maximisation procedure.</h4>

<p>As with all numerical maximisation procedures, optimization problems may arise. The function <code>Bsiland.lik()</code> allows to point out possible problems of optimization.</p>

<pre><code class="r">Bsiland.lik(resB1,land= landSiland, data=dataSiland,varnames=c(&quot;L1&quot;,&quot;L2&quot;))
</code></pre>

<p>On this graphic, the -Log-likelihood is represented. The estimation is made by maximazing the likelihood i.e. by minimizing the -Log-likelihood. The orange line indicates the minimal value obtained during the estimation. 
The black line represents the profiled -loglikelihood for L1 (i.e. the -log-likelihood values when the buffer radius for L1 is set to given values in seqd argument, seqd=seq(2,200,length=10)). The black dotted line indicates the value of L1 buffer size estimated during the global estimation procedure. The red continuous and dotted red lines simirlarly indicates the profiled -loglikelihood and the value of buffer size estimated for L2. When minization correctly occurs, the minimal values of the profiled -loglikelihoods are equal and equal the minimal value of the global -Log-likelihood. This means that the minimums of continuous black and red lines are on the orange line (and that dotted black and red lines intersect the continuous black and red lines at their minimum, respectively). If it is not the case, the minimizing procedure has failed and it is necessary to proceed with a new estimation with different initialisation values. This is possible thanks the argument <code>init</code> in function <code>Bsiland</code>. For instance, for starting estimation from buffer sizes of 20 and 150 for L1 and L2 landscape variables, respectively, use the command <code>Bsiland(obs~x1+L1+L2,land=landSiland,data=dataSiland,init=c(20,150))</code>.</p>

<h3>Spatial Influence Function approach : Fsiland()</h3>

<p>In the Spatial Influence Function (SIF) approach, each unit of landscape variable (cell/pixel) has an influence which is maximal at its location and decreases as the distance increases. For modelling a given landscape variable influence, we consider every cell where the landscape variable is distributed, and computed its influence by summing spatial influence of all cells. The spatial influence of a cell is determined by its intensity (negative or positive) and its SIF, which is a density function described by its mean distance (in <em>siland</em> package). As for the buffer approach, the <em>siland</em> package allows to estimate  the intensity of effect and the scale of effects i.e. here the mean distance of SIF. 
Estimating effects of the local variable x1 and landscape variables L1 and L2 on the variable of interest obs can be done with the command <code>Fsiland()</code> in a similar syntax than for Bsiland :</p>

<pre><code class="r">resF1=Fsiland(obs~x1+L1+L2,land=landSiland,data=dataSiland)
resF1
summary(resF1)
</code></pre>

<p>Here the parameters related to the landscape variable L1 are intensity <code>L1</code> (-8.30634) and the mean distance of its SIF, <code>SIF.L1</code> (85.0747). The vector <code>resF1$SIF</code>  gives for each landscape variable the mean distance of estimated SIFs. The data.frame <code>resF1$landcontri</code> gives for each landscape variable, the contributions for each observation (i.e. the sum of spatial influence received by each observation from all cells of the landscape).</p>

<p>The command <code>plotFsiland.sif</code> gives a representation of the estimated SIF for each landscape variable.</p>

<pre><code class="r">plotFsiland.sif(resF1)
</code></pre>

<p>The command <code>plotFsiland.land</code> gives map of effects of the landscape. 
By default, it gives the global contribution of all landscape variables:</p>

<pre><code class="r">plotFsiland.land(x=resF1,land=landSiland,data=dataSiland)
</code></pre>

<p>One can obtain a map for a specific landscape variable by specifying its number with the argument <code>var</code>:</p>

<pre><code class="r">plotFsiland.land(x=resF1,land=landSiland,data=dataSiland,var=2)
</code></pre>

<h4>Fsiland() arguments</h4>

<ul>
<li><p>The argument <code>wd</code> indicates the mesh size used to construct spatial unit (cells/pixels) of landscape variable. In fact, lanscape variable described as polygon are discretized on grid during the procedure estimation (like raster). The choice of wd is a tradeoff between computing precision and computing time (and memory size). The smallest <code>wd</code> is, the better are the precision but the longer the computing time is (and the larger the required memory size is). It is worth to note that estimated parameters can be very sensitive to this mesh size. <strong>To obtain a reliable estimation, we recommand to ensure, after the estimation procedure, that <code>wd</code> size is at least three times smaller than the smallest estimated SIF.</strong> If not, it is recommended to proceed with a new estimation with a smaller <code>wd</code> size.</p></li>
<li><p>The argument <code>border</code> indicates whether an observation receives the spatial influence of cells belonging to the same plot (i.e. the plot where the observation was made). If <code>border=T</code>, its receives influence only from the border of the plot (so no influence from the cells of the plot). By default, <code>border = F</code> (all cells are considered). </p></li>
<li><p>The argument <code>sif</code> defines the family function of SIF, i.e. the form of decrease for the landscape influence. The family can be <code>exponential</code>, <code>gaussian</code>, or <code>uniform</code>. If influence is uniform, it implies that there is no decrease of inlfuence and influence is uniform around each pixel of the raster. Note that all landscape variables have the same form. </p></li>
</ul>

<h3>Comparison between Fsiland() and Bsiland()</h3>

<p>Buffer approach modelizes landscape effect from the observation location whereas SIF approach modelizes landscape from the lanscape variables locations. These difference of point of view made difficult to compare the estimated results directly. It is possible to compare the landscape effect received by each observation, named hereafter contribution, estimated by the both models.</p>

<pre><code class="r">par(mfrow=c(2,1))
resB1$parambuffer
resF1$paramSIF
plot(resB1$buffer[,1],resF1$landcontri[,1],xlab=&quot;Buffer contribution&quot;,ylab=&quot;FIS contribution&quot;, main=&quot;Variable L1&quot;)
abline(0,1)
plot(resB1$buffer[,2],resF1$landcontri[,2],xlab=&quot;Buffer contribution&quot;,ylab=&quot;FIS contribution&quot;, main=&quot;Variable L2&quot;)
abline(0,1)
</code></pre>

<p>To compare models adequacy to data, one can compare their AIC (the smaller the better) : </p>

<pre><code class="r">resB1$AIC
resF1$AIC
</code></pre>

<h2>Model extensions</h2>

<h3>Mixed model</h3>

<p>Random effect can be included using the syntax <code>(1|  )</code>. Note that only local effect are concerned. </p>

<pre><code class="r">resB3=Bsiland(obs~x1+L1+L2+(1|Id),land=landSiland,data=dataSiland)
summary(resB3)
resF3=Fsiland(obs~x1+L1+L2+(1|Id),land=landSiland,data=dataSiland)
summary(resF3)
</code></pre>

<h3>Non gaussian model</h3>

<p>To consider distributions of the variable of interest that differ from Gaussian, use the option <code>family</code> available in the Bsiland and the Fsiland functions. Family can be &ldquo;gaussian&rdquo;, &ldquo;poisson&rdquo; or &ldquo;binomial&rdquo; and the associated link function are identity, log and logit respectively.</p>

<h3>Model with interaction between local and landscape variables</h3>

<p>Interaction between local and landscape variables using the syntax <code>:</code> or <code>*</code> (as well as localxlocal interaction). Interaction term modify the intensity of a landscape variable according to the local variable value. But the scale of effect of the landscape variable remains constant (buffer size for Bsiland or SIF mean distance for Fsiland). </p>

<pre><code class="r">#Model with main and interaction effect
resF4=Fsiland(obs~x1*L1+L2,land=landSiland,data=dataSiland)
#Model with only interaction effect
resF5=Fsiland(obs~x1:L1+L2,land=landSiland,data=dataSiland)

</code></pre>

<p>The same syntax can be applied with function Bsiland().</p>

<h3>Multiyear model and multisite model</h3>

<p>It is possible to deal with data observed during several years, i.e. data associated with several landscapes with the function <code>Bsiland</code> (this option is not implemented yet in Fsiland). 
The two data objects required are then : </p>

<ul>
<li> a <strong>list of ** data.frames of located observations, one for each year. An important point is that **data.frames column names have to be exactly the same and ordered in the same way.</strong></li>
<li> a *<em>list of *</em> sf object containing a landscape description of each year.</li>
</ul>

<p>Let us suppose we have two years of observations associated with two landscapes. Since the goal is only to show how to deal with such datasets,  we take the same datastets for observations and for landscapes for the two years.</p>

<pre><code class="r">landSilandY1=landSiland
landSilandY2=landSiland
#landSilandY is a list with the landscape for each year
landSilandY=list(landSilandY1,landSilandY2)
dataSilandY1=dataSiland
dataSilandY2=dataSiland
dataSilandY1$year=factor(&quot;2018&quot;)
dataSilandY2$year=factor(&quot;2019&quot;)
head(dataSilandY1)
head(dataSilandY2)
dataSilandY=list(dataSilandY1,dataSilandY2)
resY=Bsiland(obs~year+x1+L1+L2, land = landSilandY,data=dataSilandY)
resY
summary(resY)
</code></pre>

<p>It is possible to deal with multisite data, using the same procedure considering different sites instead of different years. </p>

<h2>Remarks</h2>

<p>As for an object ot type GLM, functions AIC(), residuals() and fitted() are available. In fact, conditionnaly to the estimated buffers or SIFs, the fitted model  is a GLM or a LMM (Linear Mixed Model) or a GLMM (Generalized Linear Mixed Model). So after an estimation with Bsiland or Fsiland(), it is possible to analyse more precisely the estimated model with the object result stored in the output. Object result is an an object from glm() or lmer() or glmer() functions.</p>

<pre><code class="r">summary(resB1$result)
BIC(resB1$result)
fitted(resF1$result)[1:10]
residuals(resF1$result)[1:10]
class(resB1$result)
class(resF1$result)

</code></pre>

<h2>Further developments</h2>

<ul>
<li>Function to deal with GIS raster files instead of shape files.</li>
<li>Estimated varoances for buffer sizes and SIF values.</li>
<li>Multiyear SIF approach</li>
</ul>

</body>

</html>
